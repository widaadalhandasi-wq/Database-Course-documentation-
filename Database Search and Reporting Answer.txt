ANSWER QUESTION 1:

Flat File Systems and Relational Databases across structure, redundancy, relationships, example usage, and drawbacks.

Structure

Flat File Systems

Single-file storage where records are stored sequentially (e.g., CSV, TXT).

No schema enforcement beyond the file structure itself.

Data stored as plain text or simple binary formats; usually delimited fields.

Relational Databases (RDBMS)

Data organized into tables (relations) with rows and columns.

Each table has a defined schema (data types, constraints, keys).

Support for indexes, views, transactions, and query engines (SQL).

Data Redundancy

Flat File Systems

High risk of redundancy — same data often duplicated across multiple files.

No built-in mechanisms for normalization or constraints.

Relational Databases

Designed to minimize redundancy via normalization (1NF, 2NF, 3NF, BCNF, etc.).

Referential integrity enforces consistent references between tables.

Relationships

Flat File Systems

Relationships (if any) must be managed manually by the application logic (e.g., matching IDs across files).

No constraints or joins at the storage layer.

Relational Databases

Native support for relationships (one-to-one, one-to-many, many-to-many) via foreign keys and join operations.

Declarative queries (SQL) allow combining related data easily.

Example Usage

Flat File Systems

Small, simple data exchange (logs, CSV exports/imports, one-off datasets).

Lightweight tools, prototypes, configuration files.

Relational Databases

Business applications, financial systems, inventory, student records, e-commerce, and any system requiring concurrency and integrity.

Drawbacks

Flat File Systems

Poor scalability for complex data; fragile integrity; inefficient queries over large datasets; no support for concurrency or transactions.

Relational Databases

More complex to set up and maintain; can be heavier resource-wise; rigid schema can be limiting for highly variable/unstructured data (but modern RDBMS and extensions mitigate this).

ANSWER QUESTION 2:
 
DBMS Advantages DIAGRAM IN FOLDER.

ANSWER QUESTION 3:

Roles in a Database System

System Analyst

Gathers requirements from stakeholders, models business processes, and translates business needs into technical specifications.

Works closely with database designers and application developers to ensure the system meets functional needs.

Database Designer

Designs logical and physical schemas, chooses normalization level, defines tables, keys, indexes, and relationships.

Ensures the model supports performance, integrity, and storage considerations.

Database Developer

Implements database objects: tables, views, stored procedures, functions, triggers, and batch jobs.

Writes and optimizes SQL queries, and collaborates with application developers to integrate the database.

DBA (Database Administrator)

Manages installation, configuration, backups, monitoring, security, and tuning of the DBMS.

Responsible for availability, recovery planning, and applying updates/patches.

Application Developer

Builds the application layer that interacts with the database through APIs/ORMs/SQL queries.

Ensures correct usage of transactions and proper handling of errors and edge cases.

BI Developer (Business Intelligence Developer)

Designs ETL/ELT processes, data warehouses/data marts, cubes, reports, and dashboards.

Translates business questions into data models and reporting artifacts for analytics.

ANSWER QUESTION 4:

Additional Research Topics
4.1 Types of Databases
Relational vs Non-Relational

Relational (SQL)

Examples: SQL Server, MySQL, PostgreSQL, Oracle.

Structured schema, ACID compliance (in many engines), strong relational model using tables, joins, and SQL.

Good for transactional systems and structured data.

Non-Relational (NoSQL)

Examples: MongoDB (document), Cassandra (wide-column), Redis (key-value), Neo4j (graph).

Flexible schemas (schema-less or schema-on-read), optimized for specific patterns (large-scale reads/writes, hierarchical data, graph traversal).

Often prioritize scalability and availability; some sacrifice strong consistency for performance (CAP theorem trade-offs).

Centralized vs Distributed vs Cloud Databases

Centralized — Single DB instance on a single server or cluster primarily accessed within a local network.

Simpler to manage for small systems.

Distributed — Data is spread across multiple nodes/locations; designed for fault tolerance, horizontal scalability, and geo-distribution.

Examples: Cassandra, CockroachDB, Google Spanner.

Cloud Databases — Managed database services provided by cloud vendors (e.g., Amazon RDS/Aurora, Azure SQL Database, Google Cloud Spanner).

Advantages: managed backups, scaling, high availability, and reduced operational overhead.

Many cloud offerings can be relational or NoSQL and can be single-region or multi-region.

Use Case Examples

OLTP systems (banking, e-commerce) — Relational databases.

Large-scale logging and time-series — NoSQL (e.g., InfluxDB, Elasticsearch).

Social networks and graph analytics — Graph databases (Neo4j).

Real-time caching — Key-value stores (Redis).

4.2 Cloud Storage and Databases
What is Cloud Storage and how does it relate to databases?

Cloud Storage refers to object/file storage services (e.g., Amazon S3, Azure Blob Storage) used to hold files, backups, and large objects. Cloud databases are managed DBMS offerings that store structured data and often use cloud storage for backup and blob data.

Cloud databases combine DBMS functionality with cloud infrastructure, offering features like automatic backups, replication, and managed scaling.

Advantages of cloud-based databases

Reduced operational overhead (managed service)

Built-in high availability and disaster recovery options

Easy vertical/horizontal scaling

Integration with other cloud services (analytics, monitoring)

Disadvantages

Vendor lock-in risk

Potentially higher cost at scale

Network latency and data sovereignty/regulatory concerns

Less control over low-level configurations

4.3 Database Engines and Languages
What is a Database Engine?

The database engine is the core software component that stores, retrieves, and manages data on disk/memory. It handles query parsing, optimization, transaction management, indexing, and storage.

Examples

Microsoft SQL Server (engine + tools)

MySQL / MariaDB

Oracle Database

PostgreSQL

Each has its own implementation details, storage engines (e.g., InnoDB for MySQL), and tooling.

What languages do they use?

SQL (ANSI SQL) — Standard query language used by most relational engines.

T-SQL — Microsoft SQL Server’s extension to SQL (procedural features).

PL/SQL — Oracle’s procedural extension to SQL.

PL/pgSQL — PostgreSQL’s procedural language variant.

Relationship between engine and language

Engines implement SQL standards and often extend them with proprietary procedural languages and functions.

While core SQL is portable, proprietary extensions (T-SQL, PL/SQL) are engine-specific and need adaptation when migrating.

Can one language work across different engines?

ANSI SQL queries (basic SELECT/INSERT/UPDATE/DELETE) are generally portable with minimal changes.

Complex features (stored procedures, window functions, system functions, certain DDL statements) may require engine-specific changes.

4.4 Can We Transfer a Database Between Engines?
Is migration possible?

Yes — migrating between engines (SQL Server → MySQL, Oracle → PostgreSQL) is possible and co.