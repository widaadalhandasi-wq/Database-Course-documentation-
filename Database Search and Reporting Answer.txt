ANSWER QUESTION 1:

Flat File Systems and Relational Databases across structure, redundancy, relationships, example usage, and drawbacks.

Structure

Flat File Systems

Single-file storage where records are stored sequentially (e.g., CSV, TXT).

No schema enforcement beyond the file structure itself.

Data stored as plain text or simple binary formats; usually delimited fields.

Relational Databases (RDBMS)

Data organized into tables (relations) with rows and columns.

Each table has a defined schema (data types, constraints, keys).

Support for indexes, views, transactions, and query engines (SQL).

Data Redundancy

Flat File Systems

High risk of redundancy — same data often duplicated across multiple files.

No built-in mechanisms for normalization or constraints.

Relational Databases

Designed to minimize redundancy via normalization (1NF, 2NF, 3NF, BCNF, etc.).

Referential integrity enforces consistent references between tables.

Relationships

Flat File Systems

Relationships (if any) must be managed manually by the application logic (e.g., matching IDs across files).

No constraints or joins at the storage layer.

Relational Databases

Native support for relationships (one-to-one, one-to-many, many-to-many) via foreign keys and join operations.

Declarative queries (SQL) allow combining related data easily.

Example Usage

Flat File Systems

Small, simple data exchange (logs, CSV exports/imports, one-off datasets).

Lightweight tools, prototypes, configuration files.

Relational Databases

Business applications, financial systems, inventory, student records, e-commerce, and any system requiring concurrency and integrity.

Drawbacks

Flat File Systems

Poor scalability for complex data; fragile integrity; inefficient queries over large datasets; no support for concurrency or transactions.

Relational Databases

More complex to set up and maintain; can be heavier resource-wise; rigid schema can be limiting for highly variable/unstructured data (but modern RDBMS and extensions mitigate this).

ANSWER QUESTION 2:
 
DBMS Advantages DIAGRAM IN FOLDER.

ANSWER QUESTION 3:

Roles in a Database System

System Analyst

Gathers requirements from stakeholders, models business processes, and translates business needs into technical specifications.

Works closely with database designers and application developers to ensure the system meets functional needs.

Database Designer

Designs logical and physical schemas, chooses normalization level, defines tables, keys, indexes, and relationships.

Ensures the model supports performance, integrity, and storage considerations.

Database Developer

Implements database objects: tables, views, stored procedures, functions, triggers, and batch jobs.

Writes and optimizes SQL queries, and collaborates with application developers to integrate the database.

DBA (Database Administrator)

Manages installation, configuration, backups, monitoring, security, and tuning of the DBMS.

Responsible for availability, recovery planning, and applying updates/patches.

Application Developer

Builds the application layer that interacts with the database through APIs/ORMs/SQL queries.

Ensures correct usage of transactions and proper handling of errors and edge cases.

BI Developer (Business Intelligence Developer)

Designs ETL/ELT processes, data warehouses/data marts, cubes, reports, and dashboards.

Translates business questions into data models and reporting artifacts for analytics.

ANSWER QUESTION 4:

Additional Research Topics
4.1 Types of Databases
Relational vs Non-Relational

Relational (SQL)

Examples: SQL Server, MySQL, PostgreSQL, Oracle.

Structured schema, ACID compliance (in many engines), strong relational model using tables, joins, and SQL.

Good for transactional systems and structured data.

Non-Relational (NoSQL)

Examples: MongoDB (document), Cassandra (wide-column), Redis (key-value), Neo4j (graph).

Flexible schemas (schema-less or schema-on-read), optimized for specific patterns (large-scale reads/writes, hierarchical data, graph traversal).

Often prioritize scalability and availability; some sacrifice strong consistency for performance (CAP theorem trade-offs).

Centralized vs Distributed vs Cloud Databases

Centralized — Single DB instance on a single server or cluster primarily accessed within a local network.

Simpler to manage for small systems.

Distributed — Data is spread across multiple nodes/locations; designed for fault tolerance, horizontal scalability, and geo-distribution.

Examples: Cassandra, CockroachDB, Google Spanner.

Cloud Databases — Managed database services provided by cloud vendors (e.g., Amazon RDS/Aurora, Azure SQL Database, Google Cloud Spanner).

Advantages: managed backups, scaling, high availability, and reduced operational overhead.

Many cloud offerings can be relational or NoSQL and can be single-region or multi-region.

Use Case Examples

OLTP systems (banking, e-commerce) — Relational databases.

Large-scale logging and time-series — NoSQL (e.g., InfluxDB, Elasticsearch).

Social networks and graph analytics — Graph databases (Neo4j).

Real-time caching — Key-value stores (Redis).

4.2 Cloud Storage and Databases
What is Cloud Storage and how does it relate to databases?

Cloud Storage refers to object/file storage services (e.g., Amazon S3, Azure Blob Storage) used to hold files, backups, and large objects. Cloud databases are managed DBMS offerings that store structured data and often use cloud storage for backup and blob data.

Cloud databases combine DBMS functionality with cloud infrastructure, offering features like automatic backups, replication, and managed scaling.

Advantages of cloud-based databases

Reduced operational overhead (managed service)

Built-in high availability and disaster recovery options

Easy vertical/horizontal scaling

Integration with other cloud services (analytics, monitoring)

Disadvantages

Vendor lock-in risk

Potentially higher cost at scale

Network latency and data sovereignty/regulatory concerns

Less control over low-level configurations

4.3 Database Engines and Languages
What is a Database Engine?

The database engine is the core software component that stores, retrieves, and manages data on disk/memory. It handles query parsing, optimization, transaction management, indexing, and storage.

Examples

Microsoft SQL Server (engine + tools)

MySQL / MariaDB

Oracle Database

PostgreSQL

Each has its own implementation details, storage engines (e.g., InnoDB for MySQL), and tooling.

What languages do they use?

SQL (ANSI SQL) — Standard query language used by most relational engines.

T-SQL — Microsoft SQL Server’s extension to SQL (procedural features).

PL/SQL — Oracle’s procedural extension to SQL.

PL/pgSQL — PostgreSQL’s procedural language variant.

Relationship between engine and language

Engines implement SQL standards and often extend them with proprietary procedural languages and functions.

While core SQL is portable, proprietary extensions (T-SQL, PL/SQL) are engine-specific and need adaptation when migrating.

Can one language work across different engines?

ANSI SQL queries (basic SELECT/INSERT/UPDATE/DELETE) are generally portable with minimal changes.

Complex features (stored procedures, window functions, system functions, certain DDL statements) may require engine-specific changes.

4.4 Can We Transfer a Database Between Engines?

1. Is it possible to migrate a database between engines (e.g., SQL Server → MySQL or Oracle → PostgreSQL)?

Yes.
Migrating a database from one engine to another is possible and is done frequently in real-world systems. Organizations migrate for reasons such as cost reduction (e.g., Oracle → PostgreSQL), cloud adoption, or moving to open-source engines.

Common migration examples:

SQL Server → MySQL

Oracle → PostgreSQL

SQL Server → PostgreSQL

MySQL → SQL Server

Oracle → MySQL

Tools like AWS DMS, Azure Database Migration Service, pgLoader, and Ora2Pg are commonly used to automate parts of the migration.

However, the process is not fully automatic because every engine has its own SQL dialect, data types, and system features.

2. Challenges of Engine-to-Engine Migration

Migrating between engines is complex because each DBMS has unique characteristics. The main challenges include:

1. Different SQL Dialects

Each DBMS has its own version of SQL:

SQL Server → T-SQL

Oracle → PL/SQL

PostgreSQL → PL/pgSQL

MySQL → ANSI SQL (with MySQL-specific extensions)

Examples of incompatible syntax:

Functions (GETDATE() vs NOW() vs SYSDATE)

Auto-increment (IDENTITY vs SERIAL vs AUTO_INCREMENT)

Joins & window functions

Error handling & procedural code

2. Data Type Differences

Each engine has unique data types and naming conventions.

During migration you must map or convert each data type.

3. Stored Procedures, Functions & Triggers

This is often the most difficult part.

Example:
A T-SQL procedure in SQL Server will not run on PostgreSQL because:

Syntax is different

Error handling differs

Cursor methods differ

Variable declaration differs

All stored logic needs to be rewritten manually in the target engine’s procedural language.

4. Constraints & Defaults

Every engine has different rules for:

Foreign keys

Cascade behavior

Unique/Check constraints

Default values

Null behavior

For example, MySQL historically ignored CHECK constraints; PostgreSQL requires strict type matching in foreign keys.

5. Indexing Differences

Engines optimize queries differently.

Oracle uses bitmap indexes heavily

PostgreSQL uses GIN/GIST indexes for JSON and full-text search

SQL Server uses clustered/non-clustered indexes

MySQL’s InnoDB engine has its own index behavior

Indexes must be re-applied and optimized based on the target engine.

6. Collations, Character Sets & Sorting Rules

Sorting and text comparison can change after migration.

Examples:

Case sensitivity differences

Unicode support inconsistencies

Sorting rules differ between engines

These can cause breaking changes in applications.

7. Application-Level Impact

Connections, drivers, ORM configurations, and query formats may need updates:

Connection strings

Parameter syntax (e.g., @var vs :var vs $1)

Pagination (OFFSET/FETCH differences)

Transaction isolation levels

3. What Should We Consider Before Transferring?

Before migration, you must evaluate:

1. Data Types Mapping

Create a mapping table showing how each type converts between engines.
This ensures no data loss or rounding issues (especially numeric types).

2. Stored Procedures, Functions & Triggers

Check:

Syntax

Error handling

Variables

Cursors

Looping logic

Plan to rewrite the code in the new procedural language.

3. Referential Integrity

Review:

Primary keys

Foreign keys

Cascades

Check constraints

Some engines enforce integrity more strictly than others.

4. SQL Queries and Application Logic

Verify:

Joins

Built-in functions

Date/time functions

String functions

Pagination logic

5. Indexes & Performance

Recreate indexes based on the target engine’s optimizer.
Query execution plans differ widely.

6. Views & Materialized Views

Some engines support materialized views differently (Oracle vs PostgreSQL).
Views may need to be rewritten.

7. Security Model

Check differences in:

User accounts

Roles and permissions

Grants

Encryption

8. Testing & Validation

Before final cut-over:

Data integrity tests

Row counts

Checksums

Query performance tests

Application regression testing.